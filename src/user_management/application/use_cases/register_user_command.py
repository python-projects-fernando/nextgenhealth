"""
Data Transfer Object for user registration input.

Uses Pydantic for automatic validation and parsing of incoming data.
Contains all required fields to construct a User entity, excluding
those generated internally (uuid, created_at, updated_at).
"""

from datetime import date
from pydantic import BaseModel, Field, field_validator

# Importing domain specifications and exceptions for reuse
from user_management.domain.specifications.user import (
    ValidNameSpecification,
    ValidEmailSpecification,
    ValidPhoneE164Specification,
    ValidDateOfBirthSpecification,
    ValidUserRoleSpecification,
)
from user_management.domain.exceptions import (
    InvalidNameError,
    InvalidEmailError,
    InvalidPhoneNumberError,
    InvalidDateOfBirthError,
    InvalidUserRoleError,
)


class RegisterUserCommand(BaseModel):
    """
    Command to register a new user in the system.

    Contains all data required to instantiate a User entity, validated by Pydantic
    and leveraging domain specifications for consistency.
    Internal fields like uuid, created_at, updated_at are generated by the system.
    """

    # --- User Identity and Contact ---
    email: str = Field(..., description="Valid email address for the user")
    first_name: str = Field(..., description="User's first name")
    last_name: str = Field(..., description="User's last name")
    phone: str = Field(..., description="User's phone number in E.164 format")

    # --- Personal Details ---
    date_of_birth: date = Field(..., description="User's date of birth (YYYY-MM-DD)")

    # --- Access Control ---
    user_role: str = Field(..., description="String representation of the user's role (e.g., PATIENT, DOCTOR)")

    # --- Security ---
    password: str = Field(..., description="User's chosen password")

    # --- Validators ---

    @field_validator('first_name', 'last_name')
    @classmethod
    def validate_name(cls, v: str) -> str:
        """
        Validate first and last names using domain specification.

        Args:
            v (str): The name value to validate.

        Returns:
            str: The validated name.

        Raises:
            InvalidNameError: If the name does not meet the specification criteria.
        """
        if not ValidNameSpecification().is_satisfied_by(v):
            raise InvalidNameError(f"Invalid name: {v}")
        return v

    @field_validator('email')
    @classmethod
    def validate_email(cls, v: str) -> str:
        """
        Validate email address using domain specification.

        Args:
            v (str): The email value to validate.

        Returns:
            str: The validated email.

        Raises:
            InvalidEmailError: If the email does not meet the specification criteria.
        """
        if not ValidEmailSpecification().is_satisfied_by(v):
            raise InvalidEmailError(f"Invalid email: {v}")
        return v

    @field_validator('phone')
    @classmethod
    def validate_phone(cls, v: str) -> str:
        """
        Validate phone number using domain specification.

        Args:
            v (str): The phone number value to validate.

        Returns:
            str: The validated phone number.

        Raises:
            InvalidPhoneNumberError: If the phone number does not meet the specification criteria.
        """
        if not ValidPhoneE164Specification().is_satisfied_by(v):
            raise InvalidPhoneNumberError(f"Invalid phone number: {v}")
        return v

    @field_validator('date_of_birth')
    @classmethod
    def validate_date_of_birth(cls, v: date) -> date:
        """
        Validate date of birth using domain specification.

        Args:
            v (date): The date of birth value to validate.

        Returns:
            date: The validated date of birth.

        Raises:
            InvalidDateOfBirthError: If the date of birth does not meet the specification criteria.
        """
        if not ValidDateOfBirthSpecification().is_satisfied_by(v):
            raise InvalidDateOfBirthError(f"Invalid date of birth: {v}")
        return v

    @field_validator('user_role')
    @classmethod
    def validate_user_role(cls, v: str) -> str:
        """
        Validate user role string against known roles.

        Args:
            v (str): The user role string to validate.

        Returns:
            str: The validated and normalized user role string.

        Raises:
            InvalidUserRoleError: If the user role is not a recognized value.
        """
        # Normalize input first to check against specification
        normalized_v = v.upper()
        if not ValidUserRoleSpecification().is_satisfied_by(normalized_v):
             raise InvalidUserRoleError(f"Invalid user role: {v}")
        return normalized_v # Return the normalized version

    @field_validator('password')
    @classmethod
    def validate_password(cls, v: str) -> str:
        """
        Basic password validation.

        Note: More complex validation might occur in UserCredentials.create.

        Args:
            v (str): The password value to validate.

        Returns:
            str: The validated password.

        Raises:
            ValueError: If the password is too short. (Consider custom exception if needed)
        """
        if len(v) < 8:
            # You can also define and use a custom exception like InvalidPasswordError
            # if it exists in your domain.
            # raise InvalidPasswordError("Password must be at least 8 characters long.")
            raise ValueError("Password must be at least 8 characters long.")
        return v

    class Config:
        """
        Pydantic model configuration.
        """
        # Allows parsing of strings to date automatically
        from_attributes = True
        # JSON encoders for complex types
        json_encoders = {
            date: lambda v: v.isoformat()
        }
        # For immutability, uncomment below
        # frozen = True
